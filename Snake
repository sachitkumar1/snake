package Snake;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;

import Utilities.GDV5;

public class Snake {

	private ArrayList<Tile> body = new ArrayList<Tile>();
	private Color color = Color.blue;
	private Tile head;
	private int direction = 2; // default RIGHT (0 = left, 1 = up, 2 = right, 3 = down)
	public Snake(int size, int startRow, int startCol) {
	    color = Color.BLUE;
	    //length of the snake is 5 in all modes except massive mode. 
	    if(size!=60) {
	    	for (int i = 0; i < 5; i++) {
	    		int x = (startCol + i) * size;
	    		int y = startRow * size;
	    		body.add(new Tile(x, y, size, size, color, startRow, startCol + i));
	    }}
	    //length of the snake is 3 in the massive mode
	    if(size == 60) {
	    	for (int i = 0; i < 3; i++) {
		        int x = (startCol + i) * size;
		        int y = startRow * size;
		        body.add(new Tile(x, y, size, size, color, startRow, startCol + i));}
	    }
	    head = body.get(0);
	}

	public void move(Board b) {
		//body follows direction of rest of body
	    for (int i = body.size() - 1; i > 0; i--) {
	        Tile current = body.get(i);
	        Tile previous = body.get(i - 1);
	        current.setDirection(previous.getDirection());
	        current.setRow(previous.getRow());
	        current.setCol(previous.getCol());
	        current.x = previous.x;
	        current.y = previous.y;
	    }

	    // Move head based on its direction
	    Tile head = body.get(0);
	    head.move();
	}

	public void turn(Board b) {
		//the 'and' statements make it so that you can't change direction vertically while moving vertically or horizontally while moving horizontally
		if((GDV5.KeysPressed[KeyEvent.VK_UP] || GDV5.KeysPressed[KeyEvent.VK_I])&& head.getDirection()!= 3) {
			//makes it so that the sound is only played once.
			if (head.getDirection()!=1) playTurnSoundUp();
			head.setDirection(1);
		}
		if((GDV5.KeysPressed[KeyEvent.VK_RIGHT] || GDV5.KeysPressed[KeyEvent.VK_L])&& head.getDirection()!= 0) {
			if (head.getDirection()!=2) playTurnSoundRight();
			head.setDirection(2);

		}
		if((GDV5.KeysPressed[KeyEvent.VK_DOWN] || GDV5.KeysPressed[KeyEvent.VK_K])&& head.getDirection()!= 1) {
			if (head.getDirection()!=3) playTurnSoundDown();
			head.setDirection(3);
		}
		if((GDV5.KeysPressed[KeyEvent.VK_LEFT] || GDV5.KeysPressed[KeyEvent.VK_J])&& head.getDirection()!= 2) {
			if (head.getDirection()!=0) playTurnSoundLeft();
			head.setDirection(0);
		}
	}
	public void setDirection(int dir) {
	    // Prevent snake reversing into itself
	    if ((this.direction == 0 && dir == 2) || (this.direction == 2 && dir == 0)) return;
	    if ((this.direction == 1 && dir == 3) || (this.direction == 3 && dir == 1)) return;
	    this.direction = dir;
	}
	public void draw(Graphics2D g) {
	    for (int i = 0; i < body.size(); i++) {
	        Tile segment = body.get(i);
	        int x = segment.x;
	        int y = segment.y;
	        int diameter = segment.width; // width=height=block size
	        //color of the snake when a life is available
	        if(invincible == true) {
	        	if(i==0) {
	        	g.setColor(new Color(80, 15, 13));}
	        	else {
	        		g.setColor(new Color(121, 19, 15));
	        	}
	        }
	        //color of snake when a life isn't available
	        else if (i == 0) {
	        	g.setColor(new Color(49, 103, 230));//head color (accurate to google snake game)
	        } else {
	            g.setColor(new Color(1, 64, 160)); // body color (accurate to google snake game)
	        }

	        g.fillOval(x, y, diameter, diameter); // draw circles for the body
	    }
	}
	
	// Returns true if any part of the snake is on the tile
	public boolean occupies(int row, int col) {
	    for (int i = 0; i < body.size(); i++) {
	        Tile t = body.get(i);
	        if (t.getRow() == row && t.getCol() == col) {
	            return true;
	        }
	    }
	    return false;
	}
	
	// Adds a new tile to the end of the snake in the opposite direction of the tail
	public void grow() {
	    Tile tail = body.get(body.size() - 1);

	    int newX = tail.x;
	    int newY = tail.y;
	    int newRow = tail.getRow();
	    int newCol = tail.getCol();
	    int size = tail.width; // Use current block size
	    int direction = tail.getDirection();
	    // opposite direction of tail
	    if (direction == 0) {
	        newX += size;
	        newCol++;
	    } else if (direction == 1) {
	        newY += size;
	        newRow++;
	    } else if (direction == 2) {
	        newX -= size;
	        newCol--;
	    } else if (direction == 3) {
	        newY -= size;
	        newRow--;
	    }

	    Tile newTile = new Tile(newX, newY, size, size, color, newRow, newCol);
	    newTile.setDirection(direction);
	    body.add(newTile);
	}


	// Returns true if head intersects with any body part
	public boolean hitSelf() {
	    Tile head = body.get(0);
	    int headRow = head.getRow();
	    int headCol = head.getCol();

	    for (int i = 1; i < body.size(); i++) {
	        Tile t = body.get(i);
	        if (headRow == t.getRow() && headCol == t.getCol()) {
	            return true;
	        }
	    }
	    return false;
	}

	// Returns the entire body of the snake
	public ArrayList<Tile> getBody() {
	    return body;
	}
	//returns the head of the snake
	public Tile getHead() {
	    return body.get(0);
	}
	//removing tail segments for the eggplant powerup
	public void removeTail() {
	    if (body.size() > 1) {
	        body.remove(body.size() - 1);
	    }
	}
	
	//code for the heart powerup
	private boolean invincible = false;
	private int collisionUsesLeft = 0;

	public void activateShield() {
	    invincible = true;
	    collisionUsesLeft = 1;
	}

	public boolean isInvincible() {
	    return invincible;
	}

	public boolean useShieldIfAvailable() {
	    if (invincible && collisionUsesLeft > 0) {
	        collisionUsesLeft--;
	        if (collisionUsesLeft == 0) {
	            invincible = false;
	        }
	        return true;
	    }
	    return false;
	}
	public void turnSoundUp() throws UnsupportedAudioFileException, IOException, LineUnavailableException {
		File turnSound = new File("Sound3.wav");
		AudioInputStream audioStream = AudioSystem.getAudioInputStream(turnSound);
		Clip clip = AudioSystem.getClip();
		clip.open(audioStream);	
		clip.start();}
	
	public void playTurnSoundUp() {
		try {
			turnSoundUp();
		} catch (UnsupportedAudioFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (LineUnavailableException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public void turnSoundRight() throws UnsupportedAudioFileException, IOException, LineUnavailableException {
		File turnSound = new File("Sound4.wav");
		AudioInputStream audioStream = AudioSystem.getAudioInputStream(turnSound);
		Clip clip = AudioSystem.getClip();
		clip.open(audioStream);	
		clip.start();}
	public void playTurnSoundRight() {
		try {
			turnSoundRight();
		} catch (UnsupportedAudioFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (LineUnavailableException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public void turnSoundDown() throws UnsupportedAudioFileException, IOException, LineUnavailableException {
		File turnSound = new File("Sound1.wav");
		AudioInputStream audioStream = AudioSystem.getAudioInputStream(turnSound);
		Clip clip = AudioSystem.getClip();
		clip.open(audioStream);	
		clip.start();}
	public void playTurnSoundDown() {
		try {
			turnSoundDown();
		} catch (UnsupportedAudioFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (LineUnavailableException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public void turnSoundLeft() throws UnsupportedAudioFileException, IOException, LineUnavailableException {
		File turnSound = new File("Sound2.wav");
		AudioInputStream audioStream = AudioSystem.getAudioInputStream(turnSound);
		Clip clip = AudioSystem.getClip();
		clip.open(audioStream);	
		clip.start();}
	public void playTurnSoundLeft() {
		try {
			turnSoundLeft();
		} catch (UnsupportedAudioFileException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (LineUnavailableException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

